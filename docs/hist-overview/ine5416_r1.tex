\documentclass{../sftex/sftex}

\title{Panorama histórico}
\author{Gustavo Zambonin}
\email{gustavo.zambonin@grad.ufsc.br}
\src{https://github.com/zambonin/ufsc-ine5416}
\uniclass{Paradigmas de Programação}
\classcode{UFSC-INE5416}

\begin{document}

\maketitle

\subsubsection*{Questão 1}
\begin{itemize}
    \item Seja uma função $x$ e um argumento $y$. O resultado da função aplicada
    ao argumento retorna um elemento semelhante a uma árvore binária, onde cada
    folha é um combinador \textbf{S}, \textbf{K} ou \textbf{I}. Todas as
    operações neste tipo de cálculo-$\lambda$ são expressadas dessa maneira.

    \begin{itemize}
        \item Combinador \textbf{S}: leva três argumentos e retorna o primeiro
        argumento aplicado ao terceiro, e isto é aplicado ao segundo argumento
        aplicado ao terceiro. Em jargão matemático: $\textbf{S}xyz = xz(yz)$.

        \item Combinador \textbf{K}: retorna a função constante de um argumento,
        que uma vez aplicada a qualquer argumento, retorna seu próprio
        argumento. Em jargão matemático: $\textbf{K}xy = x$.

        \item Combinador \textbf{I}: é um combinador utilizado apenas para
        conveniência. Retorna a identidade da função. Em jargão matemático:
        $\textbf{I}x = x$.
    \end{itemize}
\end{itemize}

\subsubsection*{Questão 2}
\begin{itemize}
    \item A tese de Church-Turing define o conceito de funções computáveis. A
    noção de computabilidade, ignorando limitações físicas e temporais, denota
    que uma função é computável se, e apenas se, for computável por uma máquina
    de Turing. Este construto teórico é matematicamente semelhante ao
    cálculo-$\lambda$ de Church e funções $\mu$-recursivas de Gödel, outras
    maneiras de provar a computabilidade de funções. Formalmente, a tese não
    pode ser provada, pois estas coincidem com a maneira informal de uma função
    efetivamente calculável (termo utilizado antes da definição de função
    computável), que não apresenta uma prova formal.
\end{itemize}

\subsubsection*{Questão 3}
\begin{itemize}
    \item Muitos tipos de paradigmas existem e seria inviável descrevê-los
    todos. Presentes nesta lista estão alguns dos mais utilizados e conhecidos.
    Linguagens como Python podem apresentar características multi-paradigma e
    darão espaço a outras com paradigmas mais definidos.

    \item Programação \textbf{declarativa} expressa a ĺógica computacional sem
    descrever seu fluxo de controle. Analogamente, programas são teorias de
    lógica formal, enquanto computações são deduções neste espaço.
    Implementações deste paradigma geralmente preocupam-se no quê o programa
    deveria resolver, ou seja, descrever seus resultados desejados, ao invés de
    como ele deveria fazê-lo.

    \begin{itemize}
        \item Programação \textbf{funcional} geralmente utiliza expressões para
        resolver os problemas, tratando computação como a resolução de funções
        matemáticas, ou seja, o resultado de uma função depende apenas de seus
        argumentos. Pode ser inferido que é difícil trabalhar com dados voláteis
        neste paradigma. Exemplos de linguagens: Erlang, Haskell, e dialetos de
        Lisp como Common Lisp e Clojure.

        \item Programação \textbf{lógica} baseia-se, como o nome diz, em lógica
        formal. Um programa escrito com este paradigma geralmente é um conjunto
        de sentenças expressando fatos e regras sobre algum problema. Exemplos
        de linguagens: Prolog e suas diversas implementações.
    \end{itemize}

    \item Programação \textbf{imperativa} descreve a computação em termos de
    sentenças que mudam o estado de um programa, analogamente ao modo imperativo
    de linguagens naturais em um diálogo. Foca em como o programa vai operar,
    quais caminhos ele tomará. Exemplos de linguagens: ALGOL, C (e suas
    derivações), COBOL, FORTRAN, Go, Java, Julia, Lua, MATLAB, Pascal, Perl,
    PHP e Ruby.

    \item Programação \textbf{paralela} é o paradigma dominante na área de
    arquitetura de computadores, especialmente na forma de processadores
    multi-\emph{core}. O princípio se baseia na divisão de grandes problemas em
    problemas menores, resolvidos ao mesmo tempo, para ganho de desempenho e
    menor gasto de energia. Exemplos de linguagens: Scala, Smalltalk e Verilog.

    \item Programação \textbf{estruturada} foca na combinação de três estruturas
    de controle: sequência, onde a ordem das rotinas importa; seleção, que
    executa certas porções de código dependendo do estado do programa; e
    iteração, onde um bloco de código ou sentença é executada até que um estado
    mude. É possível escrever um programa estruturado em qualquer linguagem de
    programação.
\end{itemize}

\newpage

\subsubsection*{Questão 4}
\begin{itemize}
    \item A lei de Moore observa que o número de transistores em um circuito
    tende a dobrar aproximadamente a cada dois anos. A indústria utiliza esta
    lei como planejamento de longo termo. Entretanto, a partir das células
    lógicas de 22 nanômetros, esta evolução tem tomado dois anos e meio,
    mostrando uma demora mais longa em desenvolver tecnologias menores, por
    conta do limite espacial dos elementos químicos que compõem as células.

    \item Richard Feynman, um grande físico do século XX, teve ideias muito à
    frente de seu tempo sobre nanotecnologia, e contribuiu conceptualmente, mas
    diretamente, para a evolução dessa ramificação da tecnologia, tornando-a
    muito mais comum nos tempos atuais.

    \item Peter Shor é conhecido primariamente por formular um algoritmo de
    fatoração de números inteiros utilizando computadores quânticos, que
    funciona exponencialmente mais rápido do que o melhor algoritmo de
    fatoração clássico existente.
\end{itemize}

\subsubsection*{Questão 5}
\begin{itemize}
    \item Um \emph{qubit} é um sistema quântico de dois estados (ou dois
    níveis) que pode ser utilizado como elemento básico de memória, guardando
    até 2 bits de informação. Utilizando uma propriedade fundamental da mecânica
    quântica chamada superposição, um qubit pode estar nos dois estados lógicos,
    0 e 1, ao mesmo tempo, processando informação de maneira mais rápida.
\end{itemize}

\subsubsection*{Questão 6}
\begin{itemize}
    \item O \emph{D-Wave} é o primeiro computador quântico comercialmente
    disponível. Ele opera sobre uma célula de 128 qubits de extensão. Desde seu
    lançamento, novas versões com mais capacidade de processamento foram
    lançadas, utilizados por entidades como Google e NASA em seus laboratórios.
\end{itemize}

\end{document}
