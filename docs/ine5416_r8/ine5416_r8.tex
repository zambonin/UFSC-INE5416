\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[a4paper, left=20mm, right=20mm, top=20mm, bottom=20mm]{geometry}
\usepackage[colorlinks=true, urlcolor=blue]{hyperref}

\begin{document}

\subsubsection*{INE5416 - Paradigmas de Programação (2015/2) \\
    Gustavo Zambonin \\
    Relatório 8 - Listas e \textit{Array}
}

\textbf{Nota}: o código-fonte em C foi compilado com
\texttt{gcc -lm ine5416\_r8.c}. Note que a compilação com \texttt{g++} falhará
por conta de um recurso chamado \textit{variable-length array}. Uma referência
sobre isto pode ser encontrada \href{http://stackoverflow.com/a/25552114}{aqui}.

\subsubsection*{Parte 1}
\begin{itemize}
    \item A declaração de \textit{arrays} em C pode ser feita de algumas
    maneiras, utilizando a notação de colchetes (\texttt{int numeros[]}, com
    número de elementos desejado opcional dentro dos colchetes), ou ponteiros
    (\texttt{int *numeros}). Estruturas multidimensionais podem ser criadas
    aumentando o número de colchetes ou de ponteiros (uma matriz pode ser
    declarada como \texttt{int matriz[][]} ou \texttt{int **matriz}). Por conta
    da tipagem da linguagem, não existem \textit{arrays} que abrigam objetos
    de tipo diferente. A inicialização destas variáveis pode ser realizada
    com alocação dinâmica de memória (\texttt{malloc} e \texttt{calloc}) ou
    através de notação de chaves englobando elementos. Não existem definições
    de listas em C, comparado a outras linguagens, além de estruturas de dados
    como listas ligadas ou circulares.

    \item Por outro lado, a declaração de listas em Python é mais dinâmica.
    Por exemplo: \texttt{lista = []} atribuirá uma lista vazia à variável
    correspondente, e também é possível popular a lista com elementos dentro
    dos colchetes; \texttt{[i for i in range(10)]} gerará uma lista onde
    $0 \leq i \leq 9$ (este método chama-se \textit{list comprehension},
    baseado originalmente na funcionalidade de Haskell). Um \textit{array}
    funciona de modo levemente diferente, pois esta estrutura é homogênea
    e \href{https://docs.python.org/2/library/array.html}{limitada} quanto ao
    tipo dos objetos que armazena.

    \item \textit{Arrays} como argumentos de funções têm diferenças apenas
    na notação, em C. O compilador sempre entenderá o argumento como um
    ponteiro, ou seja, o valor do endereço do primeiro elemento do
    \texttt{array} na memória. Assim como Python, os objetos originais serão
    modificados se passados para uma função. Para prevenir este comportamento,
    cópias em memória deverão ser realizadas.
\end{itemize}

\subsubsection*{Parte 2}
\begin{itemize}
    \item \texttt{ine5416\_r8.c} \\
    Algumas estratégias foram utilizadas para facilitar a produção do código,
    como a definição de uma pequena função para retornar o tamanho de um
    \texttt{array}, e o uso de \textit{VLAs} onde possível, evitando criação
    de arrays dinamicamente.

    \item \texttt{ine5416\_r8.py} \\
    A complexidade de espaço destas funções mostra-se claramente maior do que
    em C, porém isso se paga na facilidade de manipulação dos dados. Funções
    básicas da linguagem ajudam a simplificar os métodos. Também não é
    necessário se preocupar com alocação dinâmica de memória.
\end{itemize}

\end{document}
